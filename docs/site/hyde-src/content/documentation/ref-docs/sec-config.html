{% extends "base/_layout.html" %}

{% hyde
    section_title: Documentation
    has_exercises: "True"
    has_this_page: "True"
%}

{% block section_title %}Configuring security for a particular URL{% endblock %}

{% block exercises %}
    <li>Configure one or more URL patterns so that they match the following paths:
        <ol>
            <li>/service/crm/customer</li>
            <li>/service/crm/customer-orders</li>
            <li>/service/crm/customer-complaints</li>
            <li>/service/billing/customer</li>
            <li>/service/portal/customer</li>
            <li>/pos/1229</li>
            <li>/pos/ea67cb19</li>
        </ol>
    </li>
    <li>Try accessing a URL for which the <a href="#option-host">host</a> hasn't been configured</li>
    <li>Make the URL require <a href="#option-ssl">SSL-only access</a> and try opening it using plain HTTP.
        Does it make any difference if the credentials are correct or not?</li>
    <li>Configure the URL so that sec-wall doesn't <a href="#option-add-auth-info">add the auth info</a>.
        Make it add the information without signing it off. Try the opposite, what happens when
        the information isn't configured to be passed along yet sec-wall is to sign it off?</li>
    <li>
        Try configuring different combinations of <a href="#headers-enrichment">what headers get proxied over</a>
        in different directions.
    </li>
    <li>Have sec-wall require any valid <a href="#client-certs">client SSL/TLS certificate</a>.
        Make it require particular fields, for instance, the commonName.
    </li>
    <li>Configure <a href="#basic-auth">HTTP Basic Auth</a>, you can simply use
        your browser for testing things out.
    </li>
    <li>Have the proxy require <a href="#digest-auth">HTTP Digest Auth</a>, use the browser for making sure
        things have been configured properly
    </li>
    <li>Configure <a href="#ws-security">WS-Security</a>. What happens if both
        <a href="#option-wsse-pwd-password ">wsse-pwd-password </a> and
        <a href="#option-wsse-pwd-password-digest">wsse-pwd-password-digest</a>
        have been configured? Set
        <a href="#option-wsse-pwd-reject-empty-nonce-creation">wsse-pwd-reject-empty-nonce-creation</a> to True
        and try sending a request without the nonce. Configure
        <a href="#option-wsse-pwd-reject-stale-tokens">wsse-pwd-reject-stale-tokens</a>
        and <a href="#option-wsse-pwd-reject-expiry-limit">wsse-pwd-reject-expiry-limit</a>
        and try sending a request with an expired token.
    </li>
    <li><a href="#custom-http">Configure</a> the URL so that only requests whose
        <b>User-Agent</b> and <b>Accept-Encoding</b> headers are equal to what your browser sends
        through are allowed in. Try accessing the URL with a different browser.
    </li>
    <li>Use <a href="#xpath">XPath-based</a> access control. Prepare any XML
        document and several expressions. What happens if at least one of the
        conditions isn't fulfilled?
    </li>
{% endblock %}

{% block this_page %}
    <li><a href="#intro">Introduction</a></li>
    <li><a href="#url-patterns">URL patterns</a>
        <ol>
            <li><a href="#pesto-int">int</a></li>
            <li><a href="#pesto-unicode">unicode</a></li>
            <li><a href="#pesto-path">path</a></li>
            <li><a href="#pesto-any">any</a></li>
            <li><a href="#catch-all">/* (catch-all) pattern</a></li>
        </ol>
    </li>
    <li><a href="#sec-options">Security options</a>
        <ol>
            <li><a href="#general-options">General options</a>
                <ol>
                    <li><a href="#option-host">host</a></li>
                    <li><a href="#option-ssl">ssl</a></li>
                    <li><a href="#option-ssl-wrap-only">ssl-wrap-only</a></li>
                    <li><a href="#option-add-auth-info">add-auth-info</a></li>
                    <li><a href="#option-sign-auth-info">sign-auth-info</a></li>
                </ol>
            </li>
            <li><a href="#headers-enrichment">Headers enrichment</a>
                <ol>
                    <li><a href="#option-from-client-ignore">from-client-ignore</a></li>
                    <li><a href="#option-to-backend-add">to-backend-add</a></li>
                    <li><a href="#option-from-backend-ignore">from-backend-ignore</a></li>
                    <li><a href="#option-to-client-add">to-client-add</a></li>
                </ol>
            </li>
            <li><a href="#client-certs">SSL/TLS client certificates</a>
                <ol>
                    <li><a href="#option-ssl-cert">ssl-cert</a></li>
                    <li><a href="#option-ssl-cert-fields">ssl-cert-*</a></li>
                </ol>
            </li>
            <li><a href="#basic-auth">HTTP Basic Auth</a>
                <ol>
                    <li><a href="#option-basic-auth">basic-auth</a></li>
                    <li><a href="#option-basic-auth-username">basic-auth-username</a></li>
                    <li><a href="#option-basic-auth-password">basic-auth-password</a></li>
                    <li><a href="#option-basic-auth-realm">basic-auth-realm</a></li>
                </ol>
            </li>
            <li><a href="#digest-auth">HTTP Digest Auth</a>
                <ol>
                    <li><a href="#option-digest-auth">digest-auth</a></li>
                    <li><a href="#option-digest-auth-username">digest-auth-username</a></li>
                    <li><a href="#option-digest-auth-password">digest-auth-password</a></li>
                    <li><a href="#option-digest-auth-realm">digest-auth-realm</a></li>
                </ol>
            </li>
            <li><a href="#ws-security">WS-Security</a>
                <ol>
                    <li><a href="#option-wsse-pwd">wsse-pwd</a></li>
                    <li><a href="#option-wsse-pwd-username">wsse-pwd-username</a></li>
                    <li><a href="#option-wsse-pwd-password">wsse-pwd-password</a></li>
                    <li><a href="#option-wsse-pwd-password-digest">wsse-pwd-password-digest</a></li>
                    <li><a href="#option-wsse-pwd-reject-empty-nonce-creation">wsse-pwd-reject-empty-nonce-creation</a></li>
                    <li><a href="#option-wsse-pwd-reject-stale-tokens">wsse-pwd-reject-stale-tokens</a></li>
                    <li><a href="#option-wsse-pwd-reject-expiry-limit">wsse-pwd-reject-expiry-limit</a></li>
                    <li><a href="#option-wsse-pwd-nonce-freshness-time">wsse-pwd-nonce-freshness-time</a></li>
                </ol>
            </li>
            <li><a href="#custom-http">Custom HTTP headers</a>
                <ol>
                    <li><a href="#option-custom-http">custom-http</a></li>
                    <li><a href="#option-custom-http-headers">custom-http-*</a></li>
                </ol>
            </li>
            <li><a href="#xpath">XPath</a>
                <ol>
                    <li><a href="#option-xpath">xpath</a></li>
                    <li><a href="#option-xpath-expr">xpath-*</a></li>
                </ol>
            </li>
        </ol>
    </li>
    <li><a href="#exercises">Exercises</a></li>
{% endblock %}

{% block content %}

{% markdown %}

<h1>Configuring security for a particular URL</h1>

<h2 id="intro">Introduction</h2>

This chapter deals with the config file's <a href="/documentation/ref-docs/config-file.html#urls">urls</a>
variable exclusively. While other parts of the documentation are about
<a href="/documentation/ref-docs/config-file.html">the general syntax of the config file</a>,
this one is concerned with how one should use the *urls* variable to secure a particular
URL.

As a quick recap, here's how a sample config file may look like:

{% syntax python %}
# -*- coding: utf-8 -*-

# stdlib
import uuid

# Don't share it with anyone.
INSTANCE_SECRET = '2573116c48444b7ba90632e16e60ac5f'

# May be shared with the outside world.
INSTANCE_UNIQUE = uuid.uuid4().hex

# ##############################################################################

def default():
    return {
        'ssl': True,
        'ssl-cert': True,
        'ssl-cert-commonName':INSTANCE_SECRET,
        'host': 'http://' + INSTANCE_SECRET
    }

urls = [
    ('/*', default()),
]
{% endsyntax %}

What we'll be dealing with is what goes into the *urls* variable, which should
be a list of two-element lists or tuples. The first element is
<a href="#url-patterns">a pattern of the URL to be secured</a>,
the second one is
<a href="#sec-options">a dictionary of options</a>
that apply to the pattern.

From now on, most of the chapter's examples will show only the *urls* variable
but you still need to remember that it's merely a part, albeit an important one,
of the whole configuration file.

<h2 id="url-patterns">URL patterns</h2>

Let's discuss the following configuration:

{% syntax python %}

def config1():
    return {
        'ssl': True,
        'ssl-cert': True,
        'ssl-cert-commonName':'My Client1',
        'host': 'http://somewhere.example.com'
    }

def config2():
    return {
        'ssl': True,
        'ssl-cert': True,
        'ssl-cert-commonName':'My Client2',
        'host': 'http://somewhere.example.com'
    }

urls = [
    ('/client/1/<service_name:unicode>', config1()),
    ('/client/2/<service_name:any("customer", "billing")>', config2()),
]
{% endsyntax %}

There are two configuration dictionaries which we'll leave out for a second
but what's important now is the URL patterns. sec-wall uses
[Pesto](http://www.ollycope.com/software/pesto/) ![](/media/gfx/external-link.png)
for pattern matching and this particular patterns should read:

* '/client/1/\<service_name:unicode\>' - URL must start with the '/client/1/' string
    which is then followed by any Unicode expression, excluding '/', the path separator.
    Example URLs that will be picked up by this pattern may include
    '/client/1/invoice' and '/client/1/customer-account' whereas
    '/client/1/customer/cases' would not match.
* '/client/2/\<service_name:any("customer", "billing")\>' - URL must start with
    the '/client/1/' string and may be followed only by what's listed in the
    *any* expression. So the only matching URLs will be '/client/2/customer' and
    '/client/2/billing' but any other won't match the pattern.

You sure have noticed that expressions are named, it's *service_name* in the examples
above, and the names come in handy when configuring <a href="/documentation/ref-docs/url-rewrite.html">URL-rewriting</a>.

In run-time, patterns are checked in the order they're given in the *urls*
variable and the first match wins. The other ones are ignored and there won't
be even any information in the logs that they would've been used hadn't there been
duplicate entries.

The expression may be one of the following:
[int](#pesto-int),
[unicode](#pesto-unicode),
[path](#pesto-path)
and
[any](#pesto-any).
A related concept is a
[/* (catch-all)](#catch-all) pattern.

<h4 id="pesto-int">int</h4>

Matches any integer. Assuming a pattern in the form of '/foo/\<my_int:int\>/bar',
it would be matched by a '/foo/123/bar' URL but not if it were '/foo/zxc/bar'.

<h4 id="pesto-unicode">unicode</h4>

Matches any Unicode string, not including '/', the URL-path separator. If the pattern
is '/foo/\<my_unicode:unicode\>/bar' then both '/foo/123/bar' and '/foo/zxc/bar'
will match it yet '/foo/zxc/qwe/bar' won't because there's a '/' in there.

<h4 id="pesto-path">path</h4>

Matches any URL path. In other words, it's like [unicode](#unicode) but accepts
'/' as well. All of the following will match the '/foo/\<my_path:path\>/bar'
pattern - '/foo/123/bar', '/foo/zxc/bar' and '/foo/zxc/qwe/bar'.

<h4 id="pesto-any">any</h4>

Indicates that a part of a URL must be within a range of listed values. If there's
a '/foo/\<my_any:any("baz", "zxc")\>/bar' pattern then the only two matching URLs
will be '/foo/baz/bar' and '/foo/zxc/bar'.

<h4 id="catch-all">/* (catch-all) pattern</h4>

'/*' is a special-cased pattern not directly related to
[Pesto](http://www.ollycope.com/software/pesto/) ![](/media/gfx/external-link.png)
that catches any URL that wasn't picked up by patterns coming prior to it. Remembering
the patterns are being checked in the order they're listed in the urls
variable, you'll want to make sure '/*' always comes at the end. Because the default
strategy for handling URLs should be as secure as possible, the pattern will be automatically
injected in the list even if you don't specify it yourself, although the exact behaviour
can be customized with the
[add_default_if_not_found](/documentation/ref-docs/config-file.html#add_default_if_not_found)
variable.

<h2 id="sec-options">Security options</h2>

Once [a URL pattern has been choosen](#url-patterns), it needs to be paired
with one and more of the security options listed below. Some of the options are required
and others become required when certain parent options have been choosen.

The table below lists all the options broken out by the group they fall into
and briefly explains whether the option becomes required under certain conditions,
if at all, and what the default value is, if there is any.

You are required to provide the [host](#host) requests are destined to, zero or
more [headers enrichment-related options](#headers-enrichment) and pick one of the security schemes:
[SSL/TLS client certificates](#client-certs),
[HTTP Basic Auth](#basic-auth),
[HTTP Digest Auth](#digest-auth),
[WS-Security](#ws-security),
[Custom HTTP headers](#custom-http),
or
[XPath](#xpath).

As a quick example, let's say that we want to let the client in only if the custom HTTP *X-My-Secret*
header's value is equal to 'sSekreTT', here's how the config will look like:

{% syntax python %}
{
    'host': 'http://somewhere.example.com',
    'custom-http': True,
    'custom-http-X-My-Secret':'sSekreTT'
}
{% endsyntax %}

The table's right below and if you need usage examples, just
<a href="/documentation/usage-examples/index.html" title="Usage examples">click here</a>.

<table style="width:100%">
    <tr>
        <th>Group</th>
        <th>Option</th>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td rowspan="5"><a href="#general-options">General options</a></td>
        <td><a href="#option-host">host</a></td>
        <td>Yes</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-ssl">ssl</a></td>
        <td>Must be True if <a href="#option-ssl-wrap-only">ssl-wrap-only</a> is True,
        otherwise not required</td>
        <td>False</td>
    </tr>
    <tr>
        <td><a href="#option-ssl-wrap-only">ssl-wrap-only</a></td>
        <td>No</td>
        <td>False</td>
    </tr>
    <tr>
        <td><a href="#option-add-auth-info">add-auth-info</a></td>
        <td>No</td>
        <td>True</td>
    </tr>
    <tr>
        <td><a href="#option-sign-auth-info">sign-auth-info</a></td>
        <td>No</td>
        <td>True</td>
    </tr>
    <tr>
        <td rowspan="4"><a href="#headers-enrichment">Headers enrichment</a></td>
        <td><a href="#option-from-client-ignore">from-client-ignore</a></td>
        <td>No</td>
        <td>[] (an empty list)</td>
    </tr>
    <tr>
        <td><a href="#option-to-backend-add">to-backend-add</a></td>
        <td>No</td>
        <td>{} (an empty dictionary)</td>
    </tr>
    <tr>
        <td><a href="#option-from-backend-ignore">from-backend-ignore</a></td>
        <td>No</td>
        <td>Taken from the config's <a href="/documentation/ref-docs/config-file.html#from_backend_ignore">from_backend_ignore</a> variable</td>
    </tr>
    <tr>
        <td><a href="#option-to-client-add">to-client-add</a></td>
        <td>No</td>
        <td>{} (an empty dictionary)</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="#client-certs">SSL/TLS client certificates</a></td>
        <td><a href="#option-ssl-cert">ssl-cert</a></td>
        <td>No</td>
        <td>False</td>
    </tr>
    <tr>
        <td><a href="#option-ssl-cert-fields">ssl-cert-*</a></td>
        <td>No</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td rowspan="4"><a href="#basic-auth">HTTP Basic Auth</a></td>
        <td><a href="#option-basic-auth">basic-auth</a></td>
        <td>No</td>
        <td>False</td>
    </tr>
    <tr>
        <td><a href="#option-basic-auth-username">basic-auth-username</a></td>
        <td>Yes, if <a href="#basic-auth">basic-auth</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-basic-auth-password">basic-auth-password</a></td>
        <td>Yes, if <a href="#basic-auth">basic-auth</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-basic-auth-realm">basic-auth-realm</a></td>
        <td>Yes, if <a href="#basic-auth">basic-auth</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td rowspan="4"><a href="#digest-auth">HTTP Digest Auth</a></td>
        <td><a href="#option-digest-auth">digest-auth</a></td>
        <td>No</td>
        <td>False</td>
    </tr>
    <tr>
        <td><a href="#option-digest-auth-username">digest-auth-username</a></td>
        <td>Yes, if <a href="#digest-auth">digest-auth</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-digest-auth-password">digest-auth-password</a></td>
        <td>Yes, if <a href="#digest-auth">digest-auth</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-digest-auth-realm">digest-auth-realm</a></td>
        <td>Yes, if <a href="#digest-auth">digest-auth</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td rowspan="9"><a href="#ws-security">WS-Security</a></td>
        <td><a href="#option-wsse-pwd">wsse-pwd</a></td>
        <td>No</td>
        <td>False</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-username">wsse-pwd-username</a></td>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-realm">wsse-pwd-realm</a></td>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-password">wsse-pwd-password</a></td>
        <td>Either <a href="#option-wsse-pwd-password">wsse-pwd-password</a> or
            <a href="#option-wsse-pwd-password-digest">wsse-pwd-password-digest</a> must be given if
            <a href="#option-wsse-pwd">wsse-pwd</a> is True
        </td>
        <td>None</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-password-digest">wsse-pwd-password-digest</a></td>
        <td>Either <a href="#option-wsse-pwd-password">wsse-pwd-password</a> or
            <a href="#option-wsse-pwd-password-digest">wsse-pwd-password-digest</a> must be given if
            <a href="#option-wsse-pwd">wsse-pwd</a> is True
        </td>
        <td>None</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-reject-empty-nonce-creation">wsse-pwd-reject-empty-nonce-creation</a></td>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-reject-stale-tokens">wsse-pwd-reject-stale-tokens</a></td>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-reject-expiry-limit">wsse-pwd-reject-expiry-limit</a></td>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-wsse-pwd-nonce-freshness-time">wsse-pwd-nonce-freshness-time</a></td>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="#custom-http">Custom HTTP headers</a></td>
        <td><a href="#option-custom-http">custom-http</a></td>
        <td>No</td>
        <td>False</td>
    </tr>
    <tr>
        <td><a href="#option-custom-http-headers">custom-http-*</a></td>
        <td>Yes, if <a href="#option-custom-http">custom-http</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="#xpath">XPath</a></td>
        <td><a href="#option-xpath">xpath</a></td>
        <td>No</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="#option-xpath-expr">xpath-*</a></td>
        <td>Yes, if <a href="#option-xpath">xpath</a> is True</td>
        <td>(None)</td>
    </tr>
    <tr>
        <td><a href="/documentation/ref-docs/url-rewrite.html">URL-rewriting</a></td>
        <td><a href="/documentation/ref-docs/url-rewrite.html">rewrite</a> (not exactly a security option, added here for completness
        and documented <a href="/documentation/ref-docs/url-rewrite.html" title="URL-rewriting docs">elsewhere</a>)</td>
        <td>No</td>
        <td>(None)</td>
    </tr>
</table>

<h3 id="general-options">General options</h3>

<h4 id="option-host">host</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes</td>
        <td>(None)</td>
    </tr>
</table>

Host the client requests should be proxied over to, including scheme (http:// or https://)
and an optional port number of the backend server  but no URL path because the path - unless
[URL-rewriting](/documentation/ref-docs/url-rewrite.html)
is in effect - will be copied over as-is.

That is, by default, if sec-wall is running on
http://10.151.17.179:15000, *host* is 'http://10.152.3.191:18090' and client is accessing
the http://10.151.17.179:15000/my/service URL, sec-wall will forward it to http://10.152.3.191:18090/my/service,
without ever touching the URL path.

<h4 id="option-ssl">ssl</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Must be True if <a href="#option-ssl-wrap-only">ssl-wrap-only</a> is True,
        otherwise not required</td>
        <td>False</td>
    </tr>
</table>

If True, indicates that the sec-wall's URL must be accessed through HTTPS, plain HTTP
connections are forbidden - regardless of whether the client credentials had been supplied
and were correct.

<h4 id="option-ssl-wrap-only">ssl-wrap-only</h4>
<i>(new in 1.1)</i>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>False</td>
    </tr>
</table>

If True, indicates that the sec-wall instance is to wrap the client connection
to proxy using SSL/TLS <b>without</b> performing any authentication steps 
of whatsoever. In other words, the client connection will be encrypted but no
authentication will be performed and any auth configuration will be ignored
for the given URL pattern.

<h4 id="option-add-auth-info">add-auth-info</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>True</td>
    </tr>
</table>

Whether the backend should receive a YAML-formatted information regarding the
credentials used by the client for accessing sec-wall. Backend may use the information
for further restricting the access depending on what's in the YAML document sec-wall sends it through.
The data is sent in the HTTP  <b>X-sec-wall-auth-info</b> header and what's being forwarded depends on the
security scheme which was being used.

<ul>
    <li><b>SSL/TLS client certificates</b> - X-sec-wall-auth-info is a dictionary of
    relative distinguished names read from the client certificate's 'subject' field,
    <a href="http://docs.python.org/library/ssl.html#ssl.SSLSocket.getpeercert" title="Python's ssl.SSLSocket.getpeercert">as understood by Python</a>,
    such as:
{% syntax python %}
{commonName: MyClientApp,
    countryName: US,
    stateOrProvinceName: Alaska
    localityName: Cordova,
    organizationName: MyCompany,
    organizationalUnitName: MyUnit}
{% endsyntax %}

    </li>
    <li><b>HTTP Basic Auth</b> - X-sec-wall-auth-info is a dictionary with one key only,
    'basic-auth-username', which indicates what username the client application
    used for accessing sec-wall, such as:
{% syntax python %}
{basic-auth-username: MyUsername}
{% endsyntax %}
    </li>
    <li><b>HTTP Digest Auth</b> - X-sec-wall-auth-info is a dictionary with elements
    that point to the username and realm used by the client application when
    accessing the proxy, such as:
{% syntax python %}
{digest-auth-username: MyUsername, digest-auth-realm: My secret realm}
{% endsyntax %}
    </li>
    <li><b>WS-Security</b> - X-sec-wall-auth-info is a dictionary with one key only,
    'wsse-pwd-username', which indicates what username the client application
    used for accessing sec-wall, such as:
{% syntax python %}
{wsse-pwd-username: MyWSSEUsername}
{% endsyntax %}
    </li>
    <li><b>Custom HTTP headers</b> - X-sec-wall-auth-info is a dictionary of HTTP
    headers the client was expected to send to sec-wall, that's including both their
    names and values. Let's say the client was to send two headers, 'Accept-Encoding' equal
    to 'gzip,deflate' and 'User-Agent' equal to 'Mozilla/5.0', in that case
    X-sec-wall-auth-info will have the value of:
{% syntax python %}
{Accept-Encoding: 'gzip,deflate', User-Agent: Mozilla/5.0}
{% endsyntax %}
    </li>
    <li><b>XPath</b> - X-sec-wall-auth-info is a list of XPath that must've been
    been matched against the client request, such as:
{% syntax python %}
['//my-elem[text()="my-expected-value"]']
{% endsyntax %}
    </li>
</ul>

<h4 id="option-sign-auth-info">sign-auth-info</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>True</td>
    </tr>
</table>

Whether the <a href="#option-add-auth-info">X-sec-wall-auth-info</a> should be cryptographically
signed off. If yes, the value will sent to a backend server in the <b>X-sec-wall-auth-info-signed</b> HTTP header.
The exact formula is as follows:

delimeter = ':'
<br/>
invocation_id = <a href="/documentation/ref-docs/logging.html">as documented in the logging docs</a>
<br/>
instance_secret = <a href="/documentation/ref-docs/config-file.html#INSTANCE_SECRET">INSTANCE_SECRET</a>
<br/>
auth_info = <a href="#option-add-auth-info">X-sec-wall-auth-info</a>
<br/>
X-sec-wall-auth-info-signed = SHA256(invocation_id + delimeter + instance_secret + delimeter + auth_info)


<h3 id="headers-enrichment">Headers enrichment</h3>

<h4 id="option-from-client-ignore">from-client-ignore</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>[] (an empty list)</td>
    </tr>
</table>

List of client headers that should be ignored and never forwarded to the backend
server. Note that the names are treated case-insensitively.

Sample:

{% syntax python %}
{
    'from-client-ignore': ['User-Agent', 'Connection']
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-to-backend-add">to-backend-add</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>{} (an empty dictionary)</td>
    </tr>
</table>

A dictionary of headers to be injected by sec-wall while proxying requests to the
backend server.

Sample:

{% syntax python %}
{
    'to-backend-add': {'X-MyCustomHeader1': 'Hey there', 'X-MyCustomHeader2': "How's going, mate?"}
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-from-backend-ignore">from-backend-ignore</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>Taken from the config's <a href="/documentation/ref-docs/config-file.html#from_backend_ignore">from_backend_ignore</a> variable</td>
    </tr>
</table>

List of HTTP headers sent by a backend server that should be ignored and never
forwarded to the client application.

{% syntax python %}
{
    'from-backend-ignore': ['Server', 'Set-Cookie']
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-to-client-add">to-client-add</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>{} (an empty dictionary)</td>
    </tr>
</table>

A dictionary of headers to be injected by sec-wall while returning the backend
responses to a client application.

Sample:

{% syntax python %}
{
    'to-client-add': {'X-Powered-By': 'Python', 'Pragma': 'no-cache'}
    # .. skip other options
}
{% endsyntax %}

<h3 id="client-certs">SSL/TLS client certificates</h3>

<h4 id="option-ssl-cert">ssl-cert</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>False</td>
    </tr>
</table>

If True, the client application must use an SSL/TLS certificate when connecting
to sec-wall. The certificate needs to be signed off by one of the recognized CAs,
as configured through the <a href="/documentation/ref-docs/config-file.html#ca_certs">ca_certs</a>
variable.

Sample:

{% syntax python %}
{
    'ssl': True,
    'ssl-cert': True
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-ssl-cert-fields">ssl-cert-*</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>(None)</td>
    </tr>
</table>

In addition to stating that a client application must use
<a href="#option-ssl-cert" title="Requiring the client to use a certificate">a certificate</a>,
it's also possible to require the certificate's fields be equal to agreed values.
For instance, if you'd like the certificate not only be signed off by
<a href="/documentation/ref-docs/config-file.html#ca_certs" title="Configuring which CAs to trust">a trusted CA</a>
but also to have a 'commonName' equal to "MyClient" and 'locality' equal to 'Paris',
here's how the configuration should look like:

{% syntax python %}
{
    'ssl': True,
    'ssl-cert': True
    'ssl-cert-commonName': 'MyClient',
    'ssl-cert-locality': 'Paris'
    # .. skip other options
}
{% endsyntax %}

That is, the pattern is <b>'ssl-cert-' + FIELD_NAME: FIELD_VALUE</b>, where FIELD_NAME is
one of the certificate fields and FIELD_VALUE is the value you expect it to have.

<h3 id="basic-auth">HTTP Basic Auth</h3>

<h4 id="option-basic-auth">basic-auth</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>False</td>
    </tr>
</table>

If True, the client application is expected to use
[HTTP Basic access authentication](http://en.wikipedia.org/wiki/Basic_access_authentication)
![](/media/gfx/external-link.png)
when connecting to a sec-wall instance.

Sample:

{% syntax python %}
{
    'basic-auth': True
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-basic-auth-username">basic-auth-username</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-basic-auth">basic-auth</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The username for the client application to use when [basic-auth](#option-basic-auth) is
in effect.

{% syntax python %}
{
    'basic-auth-username': 'MyUser'
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-basic-auth-password">basic-auth-password</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-basic-auth">basic-auth</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The password for the client application to use when [basic-auth](#option-basic-auth) is
in effect. Note that it needs to be in plain text.

{% syntax python %}
{
    'basic-auth-password': 's~sSee!!Kr99e_>\eT'
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-basic-auth-realm">basic-auth-realm</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-basic-auth">basic-auth</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The realm to use when sending an HTTP 401 status to the client application.

{% syntax python %}
{
    'basic-auth-realm': 'Secure area'
    # .. skip other options
}
{% endsyntax %}

<h3 id="digest-auth">HTTP Digest Auth</h3>

<h4 id="option-digest-auth">digest-auth</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>False</td>
    </tr>
</table>

If True, the client application is expected to use
[HTTP Digest access authentication](http://en.wikipedia.org/wiki/Digest_access_authentication)
![](/media/gfx/external-link.png)
as understood by
[RFC 2069](http://tools.ietf.org/html/rfc2069) ![](/media/gfx/external-link.png)
when connecting to a sec-wall instance.

Sample:

{% syntax python %}
{
    'digest-auth': True
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-digest-auth-username">digest-auth-username</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-digest-auth">digest-auth</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The username for the client application to use when [digest-auth](#option-digest-auth) is
in effect.

Sample:

{% syntax python %}
{
    'digest-auth-username': 'MyUser'
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-digest-auth-password">digest-auth-password</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-digest-auth">digest-auth</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The password for the client application to use when [digest-auth](#option-digest-auth) is
in effect. Note that it needs to be in plain text.

Sample:

{% syntax python %}
{
    'digest-auth-password': 'Se++3Kre#t'
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-digest-auth-realm">digest-auth-realm</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-digest-auth">digest-auth</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The realm to use when sending an HTTP 401 status to the client application.

{% syntax python %}
{
    'digest-auth-realm': 'Secure area'
    # .. skip other options
}
{% endsyntax %}

<h3 id="ws-security">WS-Security</h3>

<h4 id="option-wsse-pwd">wsse-pwd</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>False</td>
    </tr>
</table>

Dictates whether client applications are required to use the
<a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf">Web Services Security: Username Token Profile V1.0 (PDF)</a>
![](/media/gfx/external-link.png) when connecting to the proxy.

<h4 id="option-wsse-pwd-username">wsse-pwd-username</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The username for the client application to use when [wsse-pwd](#option-wsse-pwd) is in effect.

<h4 id="option-wsse-pwd-password">wsse-pwd-password</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Either <a href="#option-wsse-pwd-password">wsse-pwd-password</a> or
            <a href="#option-wsse-pwd-password-digest">wsse-pwd-password-digest</a> must be given if
            <a href="#option-wsse-pwd">wsse-pwd</a> is True
        </td>
        <td>(None)</td>
    </tr>
</table>

A clear-text password to use when the password type is
http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText.

Note that *wsse-pwd-password* will have precedence if both *wsse-pwd-password*
and [wsse-pwd-password-digest](#option-wsse-pwd-password-digest) are given.

<h4 id="option-wsse-pwd-realm">wsse-pwd-realm</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The name of the realm the process of authentication takes place in.

<h4 id="option-wsse-pwd-password-digest">wsse-pwd-password-digest</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Either <a href="#option-wsse-pwd-password">wsse-pwd-password</a> or
            <a href="#option-wsse-pwd-password-digest">wsse-pwd-password-digest</a> must be given if
            <a href="#option-wsse-pwd">wsse-pwd</a> is True
        </td>
        <td>None</td>
    </tr>
</table>

A digest of the password to use when the password type is
http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest.

Note that [wsse-pwd-password](#option-wsse-pwd-password) will have precedence if both
[wsse-pwd-password](#option-wsse-pwd-password)
and *wsse-pwd-password-digest* are given.

<h4 id="option-wsse-pwd-reject-empty-nonce-creation">wsse-pwd-reject-empty-nonce-creation</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>None</td>
    </tr>
</table>

Whether requests not containing the
*/soapenv:Envelope/soapenv:Header/wsse:Security/wsse:UsernameToken/wsse:Nonce*
element should be rejected. It's recommended to set the value to True.

<h4 id="option-wsse-pwd-reject-stale-tokens">wsse-pwd-reject-stale-tokens</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

Whether requests containing stale tokens, tokens whose expiry limit has elapsed,
should be rejected. It's recommended to set the value to True and the time
after which the token is considered to have staled is given in
[wsse-pwd-reject-expiry-limit](#option-wsse-pwd-reject-expiry-limit).

<h4 id="option-wsse-pwd-reject-expiry-limit">wsse-pwd-reject-expiry-limit</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The option is in seconds and says how long after the WS-Security token
has been created it will still be considered fresh enough, that is, the client
request will be rejected if **token_creation_time + wsse-pwd-reject-expiry-limit > current_time**.

<h4 id="option-wsse-pwd-nonce-freshness-time">wsse-pwd-nonce-freshness-time</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>Yes, if <a href="#option-wsse-pwd">wsse-pwd</a> is True</td>
        <td>(None)</td>
    </tr>
</table>

The value must be set but currently sec-wall ignores it. It's meant to be used
in future sec-wall versions to aid with preventing replay attacks. It's recommended
to have it be equal to [wsse-pwd-reject-expiry-limit](#option-wsse-pwd-reject-expiry-limit).

<h3 id="custom-http">Custom HTTP headers</h3>

<h4 id="option-custom-http">custom-http</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>False</td>
    </tr>
</table>

Whether client applications should be let in depending on the occurence and
values of [configured HTTP headers](#option-custom-http-headers).

{% syntax python %}
{
    'custom-http': True
    # .. skip other options
}
{% endsyntax %}

<h4 id="option-custom-http-headers">custom-http-*</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>Yes, if <a href="#option-custom-http">custom-http</a> is True</td>
    </tr>
</table>

There must be at least one HTTP configured when [custom-http](#option-custom-http)
is True, such as in the example below where there are two of them -
**User-Agent** is expected to be **MyBrowser** and **X-MyHeader** must be
**MySecret** for sec-wall to let the request in.

{% syntax python %}
{
    'custom-http': True,
    'custom-http-User-Agent':'MyBrowser',
    'custom-http-X-MyHeader':'MySecret'
    # .. skip other options
}
{% endsyntax %}

That is, the pattern is <b>'custom-http-' + HEADER_NAME: HEADER_VALUE</b>, where HEADER_NAME is
one of the HTTP headers and HEADER_VALUE is the value it must have.

<h3 id="xpath">XPath</h3>

<h4 id="option-xpath">xpath</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>(None)</td>
    </tr>
</table>

If True, whether the client request will be let in or not will depend on a set
of XPath expressions, each of which must evaluate to True.

{% syntax python %}
{
    'xpath': True
    # .. skip other options
}
{% endsyntax %}


<h4 id="option-xpath-expr">xpath-*</h4>

<table>
    <tr>
        <th>Required</th>
        <th>Default</th>
    </tr>
    <tr>
        <td>No</td>
        <td>Yes, if <a href="#option-xpath">xpath</a> is True</td>
    </tr>
</table>

List of XPath expressions, each of them must evaluate to True for sec-wall to
consider the request be valid, like below:

{% syntax python %}

from lxml import etree

{
    'xpath': True,
    'xpath-expr1': etree.XPath('//username/value/text() = "MyUsername"'),
    'xpath-expr2': etree.XPath('//secret/value/text() = "MySecret"')
    # .. skip other options
}
{% endsyntax %}

That is, the pattern is <b>'xpath-' + EXPR_NAME: EXPR_VALUE</b>, where EXPR_NAME is
ignored and EXPR_VALUE is the value it must have. Note that EXPR_NAME may be anything
as long as it's unique for a given URL configuration. EXPR_VALUE on the other hand
is passed on directly to
[lxml](http://lxml.de) ![](/media/gfx/external-link.png)
for evaluation against the incoming requests. It is also possible to XML namespaces
with XPath, [consult this example](/documentation/usage-examples/xpath-namespaces.html)
for more information

<h2 id="examples">Examples</h2>

There's [a whole chapter devoted to nothing but showing various examples of sec-wall's configuration files](/documentation/usage-examples/index.html),
head over there for more information.

{% endmarkdown %}

{% endblock %}
